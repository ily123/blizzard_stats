import pandas as pd

class RioScraper:
    '''
    Wrapper to generate API calls to raider.io
    See raider.io API documentation at https://raider.io/api#/
    
    Attributes
    ----------
    expansion : str
        string denoting the game expansion
    dungeons : list
        list of dungeons string tokens for raider.io API
    seasons : list
        list of season string tokens for raider.io API
    regions : list
        list of region string tokens
    urls : list of strs
        list of url calls covering combinations of attributes above
        (dungeon * season * region)
    raw_data : list
        list of responses generated by the url calls to raider.io
    '''
    
    def __init__(self, expansion, dungeons, seasons, regions):
        '''
        Initializes scraper with tokens to be queried
        
        Parameters
        ----------
        expansion : str
            string denoting the game expansion
        dungeons : list
            list of dungeons tokens for raider.io API
        seasons : list
            list of season tokens for raider.io API
        regions : list
            list of region tokens
        '''
        
        self.expansion = expansion
        self.dungeons = dungeons
        self.seasons = seasons
        self.regions = regions
        
        self.raw_data = []
        
    def construct_urls(self):
        '''
        Generates url strings for all combinations of 
        seasons * dungeons * regions tokens
        
        Returns
        -------
        list
            a list of url strings to be posted to raider.io API
        '''
       
        base_url = 'https://raider.io/api/v1/mythic-plus/runs?'+\
                   'season={0}&region={1}&dungeon={2}&page={3}'
        
        urls = [base_url.format(season, region, dungeon, page)
                for season in self.seasons
                for region in self.regions
                for dungeon in self.dungeons
                for page in range(4)] # only top 100 are returned, 20/page
        return urls
                
    def query_rio(self, sleep_time=1):
        '''
        Iterates over list of url strings and posts each to raider.io
        
        Parameters
        ----------
        sleep_time : float, int, optional
            throttle calls to the API by this duration (in seconds)
            API allows no more than 2 calls per second (sleep_time >= 0.5)
            
        Returns
        -------
        list
            list of response objects generated by the API calls
        '''
        
        if sleep_time < 0.51:
            sleep_time = 0.51
            
        self.urls = self.construct_urls()
        for url in self.urls:
            response = requests.get(url)
            self.raw_data.append(response)
            time.sleep(sleep_time)
            
        return self.raw_data


class RioResponseParser:
    '''
    Parser to extract relevant data from Rio responses
    
    Attributes
    ----------
    response : API response object
        response object from a raider.io API call
    dungeon_runs : list
        list of dicts, where each dict represents a m+ run in the response
    '''
    
    def __init__(self, response):
        '''
        Constructs parser instance with a response from raider.io
        
        Parameters
        ----------
        response : obj
            response object from a raider.io API call
        '''
        self.specs = self.get_specs()
        self.response = response
        self.dungeon_runs = self.unroll()
        #print(self.specs)

    def unroll(self):
        # Extract data from the response in json format
        try:
            resp_dict = self.response.json()
        except:
            print(self.response)
            return([])
        if resp_dict['rankings']==[]:
            return([])
        # The json contains 20 nested items, each corresponding to a run,
        # convert these data into a pandas df
        datax = []
        for item in resp_dict['rankings']:
            data = {}
            data['id'] = item['run']['keystone_run_id']
            data['rank'] = item['rank']
            data['season'] = item['run']['season']
            data['dungeon'] = item['run']['dungeon']['short_name']
            data['region'] = item['run']['roster'][0]['character']['region']['slug']
            roster = item['run']['roster']
            roster_dict = self.handle_roster(roster)
            data.update(roster_dict)
            datax.append(data)
        return datax

    def handle_roster(self, roster):    
        '''
        Parse roster element of the json
        '''
        roster_dict = {}
        for character in roster:
            role = character['role']
            class_ = character['character']['class']['name']
            spec = character['character']['spec']['name']

            if (role is None) or (spec is None) or (class_ is None):
                continue
            spec = spec.lower()
            class_ = class_.lower()
            token = None
            if role == 'tank':
                token = 'tank_' + class_
            elif role == 'healer' and class_ != 'priest':
                token = 'healer_' + class_
            elif role == 'healer' and class_ == 'priest':
                token = 'healer_priest_' + spec
            elif role == 'dps':
                if class_ == 'hunter':
                    token = 'dps_hunter_' + spec     
                elif class_ == 'shaman':
                    token = 'dps_shaman_' + spec
                elif class_ == 'druid':
                    token = 'dps_druid_' + spec
                else:
                    token = 'dps_' + class_
            token = token.lower().replace(' ', '_') 
            if token in roster_dict.keys():
                roster_dict[token] += 1
            else:
                roster_dict[token] = 1

        return roster_dict

    def get_df(self):
        '''
        Converts m+ run dictionaries into a pandas df

        Returns
        -------
        data_df : DataFrame
            pandas df of the m+ run data in the raider.io response
        '''

        data_df = pd.DataFrame(self.dungeon_runs)
        return data_df
            
    def get_specs(self):
        '''
        Returns pandas df of character class/spec/role
        '''
        specs = [
            ('death knight', 'frost', 'dps', 'melee'),
            ('death knight', 'unholy', 'dps', 'melee'),
            ('rogue', 'assassination', 'dps', 'melee'),
            ('rogue', 'outlaw', 'dps', 'melee'),
            ('rogue','subtlety', 'dps', 'melee'),
            ('demon hunter', 'havoc', 'dps', 'melee'),
            ('druid', 'feral', 'dps', 'melee'),
            ('hunter', 'survival', 'dps', 'melee'),
            ('monk', 'windwalker', 'dps', 'melee'),
            ('warrior', 'arms', 'dps', 'melee'),
            ('warrior', 'fury', 'dps', 'melee'),
            ('shaman', 'enhancement', 'dps', 'melee'),
            ('paladin', 'retribution', 'dps', 'melee'),
            ('death knight', 'blood', 'tank', ''),
            ('demon hunter', 'vengeance', 'tank', ''),
            ('druid', 'guardian', 'tank', ''),
            ('monk', 'brewmaster', 'tank', ''),
            ('paladin', 'protection', 'tank', ''),
            ('warrior', 'protection', 'tank', ''),
            ('druid', 'balance', 'dps', 'range'),
            ('hunter', 'beast mastery', 'dps', 'range'),
            ('hunter', 'marksmanship', 'dps', 'range'),
            ('mage', 'arcane', 'dps', 'range'),
            ('mage', 'fire', 'dps', 'range'),
            ('mage', 'frost', 'dps', 'range'),
            ('priest', 'shadow', 'dps', 'range'),
            ('warlock', 'affliction', 'dps', 'range'),
            ('warlock', 'destruction', 'dps', 'range'),
            ('warlock', 'demonology', 'dps', 'range'),
            ('shaman', 'elemental', 'dps', 'range'),
            ('druid', 'restoration', 'healer', ''),
            ('monk', 'mistweaver', 'healer', ''),
            ('paladin', 'holy', 'healer', ''),
            ('priest', 'holy', 'healer', ''),
            ('priest', 'discipline', 'healer', ''),
            ('shaman', 'restoration', 'healer', '')
            ]

        specs_df = pd.DataFrame(specs, 
            columns=['class', 'spec', 'role', 'role_specific'])

        return specs_df
