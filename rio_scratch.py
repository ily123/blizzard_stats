import pandas as pd

class RioScraper:
    '''
    Wrapper to generate API calls to raider.io
    See raider.io API documentation at https://raider.io/api#/
    
    Attributes
    ----------
    expansion : str
        string denoting the game expansion
    dungeons : list
        list of dungeons string tokens for raider.io API
    seasons : list
        list of season string tokens for raider.io API
    regions : list
        list of region string tokens
    urls : list of strs
        list of url calls covering combinations of attributes above
        (dungeon * season * region)
    raw_data : list
        list of responses generated by the url calls to raider.io
    '''
    
    def __init__(self, expansion, dungeons, seasons, regions):
        '''
        Initializes scraper with tokens to be queried
        
        Parameters
        ----------
        expansion : str
            string denoting the game expansion
        dungeons : list
            list of dungeons tokens for raider.io API
        seasons : list
            list of season tokens for raider.io API
        regions : list
            list of region tokens
        '''
        
        self.expansion = expansion
        self.dungeons = dungeons
        self.seasons = seasons
        self.regions = regions
        
        self.raw_data = []
        
    def construct_urls(self):
        '''
        Generates url strings for all combinations of 
        seasons * dungeons * regions tokens
        
        Returns
        -------
        list
            a list of url strings to be posted to raider.io API
        '''
       
        base_url = 'https://raider.io/api/v1/mythic-plus/runs?'+\
                   'season={0}&region={1}&dungeon={2}&page={3}'
        
        urls = [base_url.format(season, region, dungeon, page)
                for season in self.seasons
                for region in self.regions
                for dungeon in self.dungeons
                for page in range(4)] # only top 100 are returned, 20/page
        return urls
                
    def query_rio(self, sleep_time=1):
        '''
        Iterates over list of url strings and posts each to raider.io
        
        Parameters
        ----------
        sleep_time : float, int, optional
            throttle calls to the API by this duration (in seconds)
            API allows no more than 2 calls per second (sleep_time >= 0.5)
            
        Returns
        -------
        list
            list of response objects generated by the API calls
        '''
        
        if sleep_time < 0.51:
            sleep_time = 0.51
            
        self.urls = self.construct_urls()
        for url in self.urls:
            response = requests.get(url)
            self.raw_data.append(response)
            time.sleep(sleep_time)
            
        return self.raw_data


class RioResponseParser:
    '''
    Parser to extract relevant data from Rio responses
    
    Attributes
    ----------
    response : API response object
        response object from a raider.io API call
    dungeon_runs : list
        list of dicts, where each dict represents a m+ run in the response
    '''
    
    def __init__(self, response):
        '''
        Constructs parser instance with a response from raider.io
        
        Parameters
        ----------
        response : obj
            response object from a raider.io API call
        '''
        self.specs, self.spec_role = self.get_specs() 
        self.specs2 = self.get_specs2()
        print(self.specs2)
        self.response = response
        self.dungeon_runs = self.unroll()
        
    def unroll(self):
        '''
        Unrolls the response, and extracts relevant data for each run
        
        Returns
        -------
        dungeon_runs : list
            list of dicts, where each dict represents a m+ run in the response
        '''
        
        # Extract data from the response in json format
        try:
            resp_dict = self.response.json()
        except:
            print(self.response)
            return([])
        # The json contains 20 nested items, each corresponding to a run,
        # save each run as a dictonary of relevant attributes
        dungeon_runs = []
        for item in resp_dict['rankings']:
            data = {}
            data['rank'] = item['rank']
            data['score'] = item['score']
            data['season'] = item['run']['season']
            data['patch'] = item['run']['dungeon']['short_name']
            data['dungeon'] = item['run']['dungeon']['short_name']
            data['faction'] = item['run']['faction']
            data['key_level'] = item['run']['mythic_level']

            affixes = [i['name'] for i in item['run']['weekly_modifiers']]
            data['affixes'] = '-'.join(affixes)
            
            out = self.parse_roster(item['run']['roster'])           
            # small number (<0.5%) of records is corrupted, skip them
            # valid records will have 1 tank, 1 healer, and 3 dps
            if [out[1], out[2], out[3]] != [1,1,3]:
                continue
            else:
                data['tank_count'] = out[1]
                data['healer_count'] = out[2]
                data['dps_count'] = out[3]
                for key, value in out[0].items():
                    data[key] = value
                
            dungeon_runs.append(data)      
        return dungeon_runs
    
    def unroll2(self):
        # Extract data from the response in json format
        try:
            resp_dict = self.response.json()
        except:
            print(self.response)
            return([])
        if resp_dict['rankings']==[]:
            return([])
        # The json contains 20 nested items, each corresponding to a run,
        # convert these data into a pandas df
        datax = []
        for item in resp_dict['rankings']:
            try:
                data = {}
                data['id'] = item['run']['keystone_run_id']
                data['rank'] = item['rank']
                data['season'] = item['run']['season']
                data['dungeon'] = item['run']['dungeon']['short_name']
                data['region'] = item['run']['roster'][0]['character']['region']['slug']
                for character in item['run']['roster']:
                    role = character['role']
                    class_ = character['character']['class']['name'].lower()
                    spec = character['character']['spec']['name'].lower()
                    # check that the role / spec combo is legal
                    if self.islegal(role, class_, spec):
                        spec_token = class_+'_'+ spec
                    else:
                        # recast spec to a legal role
                        'hi'
                    if spec_token in data.keys():
                        data[spec_token] += 1
                    else:
                        data[spec_token] = 1
                datax.append(data)
            except:
                raise 
        return datax
    
    def islegal(self, role, class_, spec):
        '''
        Checks if the role-spec combination is legal
        '''

        actual_role = self.spec_role[(class_, spec)]
        if role == actual_role:
            return True
        else:
            return False

    def suggest_correct_spec(self, role, class_, spec):
        '''
        Given a mismatch between role and spec, suggest spec legal for role
        '''
        return 0

    def parse_roster(self, roster):
        '''
        Parses the roster element of the dungeon run json
        
        Parameters
        ----------
        roster : list
            list of player character dicts
            
        
        Returns
        -------
        roster_info : tuple
            relevant info returned as tuple
        '''
                
        tank = 0
        dps = 0
        healer = 0
        data = {}
        for character in roster:
            char_role = character['role']
            if char_role == 'tank':
                dict_key = 'tank%d_' % tank
                tank += 1
            elif char_role == 'healer':
                dict_key = 'healer%d_' % healer
                healer += 1
            else:
                dict_key = 'dps%d_' % dps
                dps += 1
            data[dict_key+'name'] = character['character']['name']
            data[dict_key+'race'] = character['character']['race']['name']
            data[dict_key+'class'] = character['character']['class']['name']
            data[dict_key+'spec'] = character['character']['spec']['name']
        return (data, tank, healer, dps)

    def get_specs(self):
        '''
        Produces vector representation of player classes on roster
        '''
        melee_specs = [
            ('death knight', 'frost'), ('death knight', 'unholy'),
            ('rogue', 'assasination'), ('rogue', 'outlaw'), ('rogue','subtlety'),
            ('demon hunter', 'havoc'),
            ('druid', 'feral'),
            ('hunter', 'survival'),
            ('monk', 'windwalker'),
            ('warrior', 'arms'),
            ('warrior', 'fury'),
            ('shaman', 'enhancement'),
            ('paladin', 'retribution')
            ]

        tank_specs = [
            ('death knight', 'blood'),
            ('demon hunter', 'vengeance'),
            ('druid', 'guardian'),
            ('monk', 'brewmaster'),
            ('paladin', 'protection'),
            ('warrior', 'protection')
            ] 
        
        range_specs = [
            ('druid', 'balance'),
            ('hunter', 'beast mastery'), ('hunter', 'marksmanship'),
            ('mage', 'arcane'), ('mage', 'fire'), ('mage', 'frost'),
            ('priest', 'shadow'),
            ('warlock', 'affliction'), ('warlock', 'destruction'), ('warlock', 'demonology'),
            ('shaman', 'elemental')
            ]

        healer_specs = [
            ('druid', 'restoration'),
            ('monk', 'mistweaver'),
            ('paladin', 'holy'),
            ('priest', 'holy'), ('priest', 'discipline'),
            ('shaman', 'restoration')
            ]

        specs = {'healer' : healer_specs, 'tank' : tank_specs,
                 'melee' : melee_specs, 'range' : range_specs}
        spec_roles = {}
        for role, spec_list in specs.items():
            for spec in spec_list:
                spec_roles[spec] = role

        return [specs, spec_roles]    

 
    def get_df(self):
        '''
        Converts m+ run dictionaries into a pandas df

        Returns
        -------
        data_df : DataFrame
            pandas df of the m+ run data in the raider.io response
        '''

        data_df = pd.DataFrame(self.dungeon_runs)
        return data_df
            
            
    def get_specs2(self):
        '''
        Produces vector representation of player classes on roster
        '''
        specs = [
            ('death knight', 'frost', 'dps', 'melee'),
            ('death knight', 'unholy', 'dps', 'melee'),
            ('rogue', 'assasination', 'dps', 'melee'),
            ('rogue', 'outlaw', 'dps', 'melee'),
            ('rogue','subtlety', 'dps', 'melee'),
            ('demon hunter', 'havoc', 'dps', 'melee'),
            ('druid', 'feral', 'dps', 'melee'),
            ('hunter', 'survival', 'dps', 'melee'),
            ('monk', 'windwalker', 'dps', 'melee'),
            ('warrior', 'arms', 'dps', 'melee'),
            ('warrior', 'fury', 'dps', 'melee'),
            ('shaman', 'enhancement', 'dps', 'melee'),
            ('paladin', 'retribution', 'dps', 'melee'),
            ('death knight', 'blood', 'tank', ''),
            ('demon hunter', 'vengeance', 'tank', ''),
            ('druid', 'guardian', 'tank', ''),
            ('monk', 'brewmaster', 'tank', ''),
            ('paladin', 'protection', 'tank', ''),
            ('warrior', 'protection', 'tank', ''),
            ('druid', 'balance', 'dps', 'range'),
            ('hunter', 'beast mastery', 'dps', 'range'),
            ('hunter', 'marksmanship', 'dps', 'range'),
            ('mage', 'arcane', 'dps', 'range'),
            ('mage', 'fire', 'dps', 'range'),
            ('mage', 'frost', 'dps', 'range'),
            ('priest', 'shadow', 'dps', 'range'),
            ('warlock', 'affliction', 'dps', 'range'),
            ('warlock', 'destruction', 'dps', 'range'),
            ('warlock', 'demonology', 'dps', 'range'),
            ('shaman', 'elemental', 'dps', 'range'),
            ('druid', 'restoration', 'healer', ''),
            ('monk', 'mistweaver', 'healer', ''),
            ('paladin', 'holy', 'healer', ''),
            ('priest', 'holy', 'healer', ''),
            ('priest', 'discipline', 'healer', ''),
            ('shaman', 'restoration', 'healer', '')
            ]

        specs_df = pd.DataFrame(specs, 
            columns=['class', 'spec', 'role', 'role_specific'])

        return specs_df
